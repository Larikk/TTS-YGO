#include <../common/Base>

--Constants
local SET_NAME = "Legend of Blue Eyes White Dragon"
local SET_NAME_URL = "legend%20of%20blue%20eyes%20white%20dragon"
local CARDS_IN_PACKS = 9
local PACKS_IN_BOX = 24

-- Rarities
local COMMON = "Common"
local RARE = "Rare"
local SUPER_RARE = "Super Rare"
local ULTRA_RARE = "Ultra Rare"
local SECRET_RARE = "Secret Rare"

-- We want to map some rarities to other rarities (eg. when we want to treat a shortprint as a common)
local ALTERNATIVE_RARITIES = {}
ALTERNATIVE_RARITIES["Short Print"] = COMMON

-- Ratios for last card, must add up to 100
local RATIOS = {}
RATIOS[COMMON] = 0.71
RATIOS[SUPER_RARE] = 0.17
RATIOS[ULTRA_RARE] = 0.08
RATIOS[SECRET_RARE] = 0.04


PackGenerator = AbstractPackGenerator:new()

function PackGenerator:assemblePack(cardsMap)
    local pack = {}

    -- generates one more than needed for possible 9th card
    local commonsSequence = Math:randomSequence(8, cardsMap[COMMON].count)

    -- 7 commons
    for i = 1, 7 do
        local commonIndex = commonsSequence[i]
        pack[i] = cardsMap[COMMON][commonIndex]
    end

    -- guaranteed 1 rare
    local rareIndex = Math:randomInt(cardsMap[RARE].count)
    pack[8] = cardsMap[RARE][rareIndex]

    -- wild card
    local lastRarity = self:pickRarity(RATIOS)
    local lastIndex = nil
    if lastRarity == COMMON then
        lastIndex = commonsSequence[8]
    else
        lastIndex = Math:randomInt(cardsMap[lastRarity].count)
    end
    pack[9] = cardsMap[lastRarity][lastIndex]

    return pack
end

function PackGenerator:new()
    o = AbstractPackGenerator:new()
    setmetatable(o, self)
    self.__index = self

    self.setName = SET_NAME
    self.setNameUrl = SET_NAME_URL
    self.cardsInPacks = CARDS_IN_PACKS
    self.packsInBox = PACKS_IN_BOX
    self.rarityReplacements = ALTERNATIVE_RARITIES

    return o
end
