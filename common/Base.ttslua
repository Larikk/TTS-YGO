#include <Spawner>
#include <CardParser>
#include <Math>
#include <IO>

-- We are using a third party JSON library because the native JSON deserialization of TTS is very slow
-- Benchmark of 10 decode calls for one booster set: library = ~15sec, native = ~300s
--
-- Code is taken from https://github.com/rxi/json.lua
-- Some changes were made to make it work with TTS
#include <Json>


-- Abstract class which has common logic
-- Pack-specific behavior is implemented is subclasses
AbstractPackGenerator = {}


local function noop()
    error("This abstract function has no implementation and must be overriden by a specific pack generator.")
end

-- Must be implemented by a specific generator
function AbstractPackGenerator:assemblePack()
    noop()
end

function AbstractPackGenerator:assembleBox()
    local packs = {}
    for i = 1, self.packsInBox do
      table.insert(packs, self:assemblePack())
    end
    return packs
end

function AbstractPackGenerator:pickSingleCard(rarity)
    local index = Math:randomInt(self.cardsMap[rarity].count)
    return self.cardsMap[rarity][index]
end

function AbstractPackGenerator:pickMultipleCards(rarity, n)
    local cards = {}
    local sequence = Math:randomSequence(n, self.cardsMap[rarity].count)

    for i, v in ipairs(sequence) do
        cards[i] = self.cardsMap[rarity][v]
    end

    return cards
end

-- Each card has all of its releases in the card_sets array
-- Releases can have different rarities so thats why we have to determine the right one
-- rarityReplacements is a mapping between rarities
-- It's used if we want to replace a rarity with another one (like "Short Print" to "Common")
function AbstractPackGenerator:extractRarity(card)
    rarityReplacements = self.rarityReplacements or {}
    for i, set in ipairs(card.card_sets) do
        if set.set_name == self.setName then
          return rarityReplacements[set.set_rarity] or set.set_rarity
        end
    end

    return nil
end


-- ratios is a table
-- key: rarity
-- value: possibility of the rarity
-- values should add up to 1.0
function AbstractPackGenerator:pickRarity(ratios)
    local p = Math:randomFloat()
    local fallbackRarity = nil

    for rarity, ratio in pairs(ratios) do
        if (p < ratio) then
            return rarity
        end
        p = p - ratio
        fallbackRarity = rarity
    end

    IO:warning(
      "An error occurred while determining a random rarity for a single card. "..
      "Ratios may be misconfigured (Have to add up to 1.0). Defaulting to highest: "..fallbackRarity..
      ". Provided ratios:\n"..IO:tableToString(ratios)
    )

    return fallbackRarity
end

-- Can be overridden by subclasses if necessary
function AbstractPackGenerator:parseCardList(cardList)
    local cardsMap = {}

    for i, card in ipairs(cardList) do
        local rarity = self:extractRarity(card, self.setName, self.rarityReplacements)

        if rarity == nil then
            IO:warning(string.format("Could not extract rarity of %s, removing from card pool", card.name))
            goto continue
        end

        card.rarity = rarity

        if cardsMap[rarity] == nil then
            cardsMap[rarity] = {}
            cardsMap[rarity].count = 0
        end

        table.insert(cardsMap[rarity], CardParser:parseCard(card))
        cardsMap[rarity].count = cardsMap[rarity].count + 1
        ::continue::
    end

    return cardsMap
end


function AbstractPackGenerator:processAPIResponse(response, callback)
    IO:info("Received card list, processing response...")
    local cards = Json:decode(response.text).data

    self.cardsMap = self:parseCardList(cards)
    IO:info("Processed card list, continuing with spawning.")
    if type(callback) == "function" then callback() end
end

-- downloads the card list from db.ygoprodeck.com and initializes initCardsMap
-- callBack should be the action that should have been executed if cardsMap were initialized
function AbstractPackGenerator:initCardsMap(callback)
    IO:info("Downloading card list...")
    WebRequest.get("https://db.ygoprodeck.com/api/v7/cardinfo.php?cardset="..self.setNameUrl,
        function(response) self:processAPIResponse(response, callback) end
    )
end

-- spawns a booster, can be called externally
function AbstractPackGenerator:generateBoosterPack()
    local f = function()
        local pack = self:assemblePack()
        local spawner = Spawner:new(self.cardsInPacks)
        spawner:spawnBox(pack, || IO:success("Pack is ready!"))
    end

    if self.cardsMap == nil then
        self:initCardsMap(|| f())
    else
        f()
    end
end

-- spawns a box, can be called externally
function AbstractPackGenerator:generateBoosterBox()
    local f = function()
        local packs = self:assembleBox()
        local spawner = Spawner:new(self.cardsInPacks, self.packsInBox)
        spawner:spawnBox(packs, || IO:success("Box is ready!"))
    end

    if self.cardsMap == nil then
        self:initCardsMap(|| f())
    else
        f()
    end
end

-- just for developing new packs
function AbstractPackGenerator:printRarities()
  local f = function()
    for k, v in pairs(self.cardsMap) do
      print(string.format("%s: %d", k, v.count))
    end
  end

  if self.cardsMap == nil then
      self:initCardsMap(|| f())
  else
      f()
  end
end

function AbstractPackGenerator:new(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self

    -- must be overridden by specific generators
    self.setName = nil
    self.setNameUrl = nil
    self.cardsInPacks = nil
    self.packsInBox = nil
    self.rarityReplacements = {}

    -- is initialized before a box/pack is generated for the first time
    -- holds the cards of the set partitioned by their rarity
    -- key: rarity
    -- value: tables with the single cards, indexed with numbers and a count field
    self.cardsMap = nil

    return o
end
